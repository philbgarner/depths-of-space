{"version":3,"file":"tactics.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAiB,QAAID,IAErBD,EAAc,QAAIC,GACnB,CATD,CASGK,MAAM,I,mBCRT,IAAIC,EAAsB,CCA1BA,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,IAE1E,ECNDF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFT,EAAyBL,IACH,oBAAXkB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeV,EAASkB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeV,EAAS,aAAc,CAAEoB,OAAO,GAAO,G,8tBCH9D,IAAIC,EAAM,KAEV,SAASC,EAAWC,GAChBF,EAAME,CACV,CAEA,SAASC,IACL,OAAOH,CACX,CAWA,SAASI,EAAUC,EAAMC,EAAGC,EAAGC,GAC3B,IAAIC,EAAM,UAAcC,GAAKA,EAAEL,OAASA,IACpCI,EAAIE,OAAS,IACTH,EACAR,EAAII,UAAUK,EAAI,GAAGG,MAAOJ,EAAQF,EAAGE,EAAQD,EAAGC,EAAQK,EAAGL,EAAQM,EAAGR,EAAGC,EAAGC,EAAQK,EAAGL,EAAQM,GAEjGd,EAAII,UAAUK,EAAI,GAAGG,MAAON,EAAGC,GAG3C,C,w1BCZA,SAASQ,EAAmBC,GAExB,OAAOA,EADC,IAAIC,KAAKD,GACJE,SAAS,EAAE,EAAE,EAAE,EAC5B,CAEJ,SAASC,EAAYd,EAAMC,EAAGC,EAAGa,EAAMC,GACnC,IAAK,EAAWhB,GACZ,MAAM,IAAIiB,MAAM,qDAAqDjB,OAEzE,IAAIkB,EAAS,CACTlB,KAAMA,EACNC,EAAGA,EAAGC,EAAGA,EACTiB,OAAQ,GACRJ,KAAMA,EACNK,YAAa,KACbC,aAAc,EACdC,YAAa,EACbC,MAAM,EAEVL,aAAsB,CAACM,EAAWT,EAAMC,KACpCE,EAAOO,cAAgBf,EAAmB,IAAIE,MAC9C,IAAIc,EAAO,EAAWF,GAItB,GAHIR,IACAE,EAAOF,WAAaA,GAEpBU,EAAM,CACN,IAAIC,EAAUD,EAAKE,QAAUF,EAAKE,QAAU,KAE5C,GADAD,EAAUD,EAAKX,GAAQW,EAAKX,GAAQY,EAChCA,EAAS,CAET,KD9BL,EC6B2BE,QAAOxB,GAAKA,EAAEL,OAAS2B,EAAQG,YAC7CxB,OAAS,GAab,MAAM,IAAIW,MAAM,mBAAmBF,QAAWS,MAP9C,GALAN,EAAOC,OAASQ,EAAQR,OACxBD,EAAOG,aAAe,EACtBH,EAAOM,UAAYA,EACnBN,EAAOH,KAAOA,EACdG,EAAOE,YAAcO,EAAQG,UACzBH,EAAQI,IAAK,CACb,IAAIA,EAAMC,OAAOL,EAAQI,KACrBA,GACAA,EAAIR,MAEZ,CAIR,MACIL,EAAOC,OAAS,GAChBD,EAAOG,aAAe,EACtBH,EAAOM,UAAY,GACnBN,EAAOH,KAAO,GAElBG,EAAOK,MAAO,CAClB,GAEJL,KAAc,CAACe,EAASC,KACpBD,EAAUA,GAAoB,EAC9BC,EAAUA,GAAoB,EAC9BnC,EAAUmB,EAAOE,YAAaF,EAAOjB,EAAIgC,EAASf,EAAOhB,EAAIgC,EAAShB,EAAOC,OAAOD,EAAOG,cAAa,EAE5GH,OAAgBiB,MAAOlC,EAAGC,EAAGkC,IAClB,IAAIC,SAAQF,MAAOG,EAASC,KAC/B,IAAIC,EAAMtB,EACNuB,EAAKD,EAAIvC,EACTyC,EAAKF,EAAItC,EACTyC,EAAMP,EACNQ,EAAI,EACG,IAACC,EAAIC,QAAJD,EAiBD5C,EAjBK6C,EAiBF5C,EAjBS,IAAImC,SAAQ,CAACC,EAASC,KACzC,IAAIQ,EAAU,KAEV,GADAH,GAAKD,EACDC,GAAK,EACLJ,EAAIvC,EAAIA,EACRuC,EAAItC,EAAIA,EACRoC,QACG,CACH,IAAIU,EArFjB,CAAE/C,GAAI,GADkBgD,EAsF4CL,KAtFxDM,EAsFoB,CAAEjD,EAAGwC,EAAIvC,EAAGwC,IArFzBzC,EAAEgD,GADFE,EAsF+B,CAAElD,EAAG4C,EAAI3C,EAAG4C,IArFjC7C,EAAGC,GAAI,EAAE+C,GAAKC,EAAMhD,EAAE+C,EAAIE,EAAIjD,GAsF9CsC,EAAIvC,EAAI+C,EAAE/C,EACVuC,EAAItC,EAAI8C,EAAE9C,EACVkD,WAAWL,EAAS,GACxB,CA1FlB,IAAqBG,EAAOC,EAAKF,CA0Ff,EAEJG,WAAWL,EAAS,GAAE,KAI1BT,GAAQ,KAgChB,OA7BApB,EAAOF,WAAaA,GAA0B,CAACE,IAAD,GAC9CA,EAAOmC,OAAUC,IACb,IAAI3B,EAAU,EAAWT,EAAOM,WAAWN,EAAOH,MAC9CY,GAAWT,EAAOK,OACdL,EAAOI,YAAcK,EAAQ4B,YAC7BrC,EAAOG,eACHH,EAAOG,aAAeH,EAAOC,OAAOb,OAAS,IACzCqB,EAAQ6B,QACRtC,EAAOG,aAAe,EACtBH,EAAOuC,aAAe/C,EAAmB,IAAIE,MAAUM,EAAOO,cAC9DP,EAAOF,WAAWE,KAElBA,EAAOuC,aAAe/C,EAAmB,IAAIE,MAAUM,EAAOO,cAC9DP,EAAOG,eACPH,EAAOK,MAAO,EACdL,EAAOF,WAAWE,IAElBS,EAAQX,YACRW,EAAQX,WAAWE,IAG3BA,EAAOI,YAAc,GAErBJ,EAAOI,aAAegC,EAE9B,EAEJpC,EAAOwC,aAAa1D,EAAMe,GAEnBG,CACX,CChIA,SAASyC,EAAKC,GAEV,IADAA,EAAOA,EAAKC,eACFC,SAAS,KAEZ,CACH,IAAIC,EAAUH,EAAKI,MAAM,KACrBf,EAAM,EACV,IAAK,IAAIgB,EAAQ,EAAGA,EAAQF,EAAQ,GAAIE,IACpChB,IAbKiB,EAaU,EAbLC,EAaQJ,EAAQ,GAX3BK,KAAKC,MAAMD,KAAKE,UAAYH,EAAMD,EAAM,GAAKA,IAahD,OAAOjB,CACX,CAhBJ,IAAiBiB,EAAKC,EAQd,MAAM,IAAIlD,MAAM,qDASxB,CCjBA,IAAIsD,EAAQ,GACRC,EAAY,EACZC,EAAS,CAAC,cAAe,WAAY,SAAU,QAAS,UACxDC,EAAQ,EAEZ,SAASC,EAAQ3E,EAAM4E,GACnB,IAAIC,EAAO,CACP7E,KAAMA,EACN8E,MAAO,YACPC,MAAOpB,EAAKiB,IAIhB,OAFAL,EAAMS,KAAKH,GACXN,EAAMU,MAAK,CAACC,EAAGC,IAAMA,EAAEJ,MAAQG,EAAEH,QAC1BF,CACX,CAEA,SAASO,EAAQpF,GACb,IAAI6E,EAAON,EAAM1C,QAAOxB,GAAKA,EAAEL,OAASA,IACxC,OAAO6E,EAAKvE,OAAS,EAAIuE,EAAK,GAAK,IACvC,CAEA,SAASQ,IACL,OAAOd,EAAMC,EACjB,CAEA,SAASc,IACL,OAAOb,EAAOC,EAClB,CCxBA,IAAIa,EAAM,KAGNC,EAAS,GAGTC,EAAc,GAKdC,EAAgB,KAEhBC,EAAQ,GAERC,EAAS,CACT3F,EAAG,GACHC,EAAG,IAAM2F,EACTrF,EAAG,IAAMqF,EAAgBpF,EAAG,IAAMoF,EAClCC,QAAS,EACTC,QAAS,IAAMF,GAOnB,SAASG,EAAiBC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIrG,EAAGC,GAEjD,IAAIqG,GAAOJ,EAAKF,IAAOK,EAAKJ,IAAOE,EAAKF,IAAOG,EAAKJ,GAEpD,OAAQM,IAAQJ,EAAKF,IAAO/F,EAAIgG,IAAOE,EAAKF,IAAOjG,EAAIgG,KAAQ,GACvDM,IAAQF,EAAKF,IAAOjG,EAAIkG,IAAOE,EAAKF,IAAOnG,EAAIkG,KAAQ,GACvDI,IAAQN,EAAKI,IAAOnG,EAAIoG,IAAOJ,EAAKI,IAAOrG,EAAIoG,KAAQ,CAEnE,CAEA,SAASG,EAAQC,EAAUC,GACvB,IAAIC,EAAQ,IAAI,EAAM,CAClB9B,KAAMO,EAAQqB,GACdzG,KAAM0G,EAAK1G,KACX4G,UAAWF,EACXG,WAAY,SACZ5G,EAAG,EACHC,EAAG,IAGP,OADAyF,EAAMX,KAAK2B,GACJA,CACX,CAEA,SAASG,EAASL,GAEd,OADAM,QAAQC,IAAIP,EAAUd,GAClBc,EACOd,EAAM9D,QAAOxB,GAAKA,EAAEwE,KAAK7E,OAASyG,IAElCd,CAEf,CAyCA,SAASE,IACL,MAAO,CAAE5F,EAAG4F,EAAgB3F,EAAG2F,EACnC,CChFA,QArBA,MACIoB,YAAYC,GACRC,KAAKtC,KAAOqC,EAAOrC,KACnBsC,KAAKnH,KAAOkH,EAAOlH,KACnBmH,KAAKP,UAAYM,EAAON,UACxBO,KAAKjG,OAASJ,EAAYoG,EAAOL,WAAYK,EAAOjH,EAAIiH,EAAOjH,EAAI,EAAGiH,EAAOhH,EAAIgH,EAAOhH,EAAI,EAAG,OACnG,CAEAkH,WACI,MAAO,CAAEnH,EAAGkH,KAAKjG,OAAOjB,EAAGC,EAAGiH,KAAKjG,OAAOhB,EAC9C,CAEAmH,YACI,MAAO,CAAEpH,EAAGqH,SAASH,KAAKjG,OAAOjB,EAAI,IAAWA,GAAIC,EAAGoH,SAASH,KAAKjG,OAAOhB,EAAI,IAAWA,GAC/F,CAEAqH,KAAKjE,GACD6D,KAAKjG,OAAOsG,KAAKlE,EACrB,GCjBJ,IAAImE,EAAM,KAEN,EAAM,KAENC,EAAU,GAad,SAASC,IACL,GAAuB,gBAAnBrC,IAAkC,CAClC,IAAIK,EAAQmB,EAASzB,IAAcrF,MACnC+G,QAAQC,IAAI3B,KACRM,EAAMrF,OAAS,IFEDY,EEDGyE,EAAM,GAAGzE,OFElCwE,EAAgBxE,EEAhB,CFDJ,IAA0BA,CEE1B,C,8TC5BA,IAAI0G,GAAY,EAMhB,SAASC,EAAiBC,GACxBC,EAASD,GAAQ,GACbE,EAAUF,IACZE,EAAUF,GAAQA,EAEtB,CAYA,IAAIG,EAAa,CAAC,EACdD,EAAY,CAAC,EAEbE,EAAU,CAAE,WAAY,WAE5B,SAASH,EAASD,EAAQpI,GACxBuI,EAAWH,GAAUpI,CACvB,CASA,SAASyI,EAAgBC,GACvB,IAAKR,EACH,OAEF,IAAIS,EAAStJ,OAAOuJ,KAAK,KACzB,IAAK,IAAIC,KAAKF,EACRD,EAAEvJ,MAAQ,IAAcwJ,EAAOE,KA1CrCR,EA2CmBM,EAAOE,IA3CT,EA8CnB,CAEA,SAASC,EAAcJ,GACrB,IAAKR,EACH,OAEF,IAAIS,EAAStJ,OAAOuJ,KAAK,KACzB,IAAK,IAAIC,KAAKF,EACRD,EAAEvJ,MAAQ,IAAcwJ,EAAOE,KACjCV,EAAgBQ,EAAOE,GAG7B,CAGEN,EAAa,CAAC,EACdD,EAAY,CAAC,EACTE,EAAQpE,SAAS,cACnB2E,OAAOC,oBAAoB,UAAWP,GACtCM,OAAOC,oBAAoB,QAASF,GACpCC,OAAOE,iBAAiB,UAAWR,GACnCM,OAAOE,iBAAiB,QAASH,IAE/BN,EAAQpE,SAAS,YACnB8E,YAAYC,GAAG,WAAW,SAASC,GACjC,IAAIT,EAAStJ,OAAOuJ,KAAK,KACzB,IAAK,IAAIC,KAAKF,EACZS,EAAQD,GAAG,IAAaR,EAAOE,KAAK,SAEjCQ,MAAM,IAAaV,EAAOE,KAAK,KAChCV,EAAgBQ,EAAOE,GAAE,GAG/B,IAEFX,GAAY,EAiBd,QAZY,CACVoB,OAAQ,KACNpB,GAAY,GAEdqB,SAAU,KACRrB,GAAY,GAEdsB,SAAU,CAACpB,EAAQqB,KACjBnB,EAAUF,GAAUqB,I,+3BC/FxB,MAAMC,EACFnC,YAAYjH,GAER,IACImH,KAAKkC,KAAO,UAAkBhJ,GAAKA,EAAEL,OAASA,IAAM,GACpDmH,KAAKkC,KAAKC,MAAQnC,KAAKkC,KAAKE,GAC5BpC,KAAKnH,KAAOmH,KAAKkC,KAAKrJ,KACtBmH,KAAKqC,UAAY,EACrB,CAAE,MACErC,KAAKkC,KAAO,CAAC,EACbtC,QAAQ0C,MAAM,iCAAiCzJ,KACnD,CAGAmH,KAAKuC,gBAAkB,CAAC,EAIxBvC,KAAKwC,QAAU,EACnB,CAMAC,gBACI,IAAK,IAAIxB,KAAKjB,KAAKwC,QAAS,CACxB,IAAIE,EAAS1C,KAAKwC,QAAQvB,GACtByB,EAAOC,KACPD,EAAOC,MAEPD,EAAOC,KAAO,GACd3C,KAAK4C,qBAAqBF,EAElC,CACA1C,KAAKwC,QAAUxC,KAAKwC,QAAQ9H,QAAOxB,GAAKA,EAAEyJ,IAAM,GACpD,CAEAE,UAAUH,GACFA,EAAOC,KACP3C,KAAKwC,QAAQ3E,KAAK6E,QAEGI,IAArBJ,EAAOK,WACP/C,KAAKgD,kBAAkBN,EAAOK,UAAWL,EAAOO,OAExD,CACAL,qBAAqBF,QACQI,IAArBJ,EAAOK,WACP/C,KAAK6C,UAAUH,EAAOK,WAA4B,EAAjBL,EAAOO,OAEhD,CAEAD,kBAAkBD,EAAWE,QACeH,IAApC9C,KAAKuC,gBAAgBQ,KACrB/C,KAAKuC,gBAAgBQ,GAAa,GAEtC/C,KAAKuC,gBAAgBQ,IAAcE,CACvC,CAEAC,eAAeH,GACX,YAAwCD,IAApC9C,KAAKuC,gBAAgBQ,GACd/C,KAAKuC,gBAAgBQ,GAEzB,CACX,CAEAI,OACI,OAAOnD,KAAKkC,KAAKrJ,IACrB,CAEAuK,OACI,OAAOpD,KAAKkC,KAAKkB,KAAOpD,KAAKkD,eAAe,OAChD,CAEAG,sBAAsBC,GAIlB,YAHaR,IAATQ,IACAtD,KAAKkC,KAAKqB,eAAiBD,GAExBtD,KAAKkC,KAAKqB,eAAiBvD,KAAKkD,eAAe,iBAC1D,CAEAM,eACI,OAAOxD,KAAKkC,KAAKuB,aAAezD,KAAKkD,eAAe,eACxD,CAEAQ,aACI,OAAO1D,KAAKkC,KAAKyB,WAAa3D,KAAKkD,eAAe,aACtD,CAEAU,QACI,OAAO5D,KAAKkC,KAAKjH,MAAQ+E,KAAKkD,eAAe,QACjD,CAEAW,KACI,OAAO7D,KAAKkC,KAAKE,GAAKpC,KAAKkD,eAAe,KAC9C,CAEAY,QACI,OAAO9D,KAAKkC,KAAKC,MAAQnC,KAAKkD,eAAe,QACjD,E,u7LC5FJ,IAAI,EAAM,KAEN,EAAM,KAEV,IAAIa,EAAQ,GAERC,EAAQ,GAERC,EAAatK,EAAY,aAAc,EAAG,EAAG,QAG7CuK,EAAY,GACZC,GAAW,CAAC,EACZC,GAAgB,OAChBC,GAAkB,QAClBC,GAAoB,EAEpBC,GAAwB,KAExBC,GAAc,CACdC,uBAAwB,CAACC,EAAMC,IACpB,CAACZ,EAAMa,YAElBC,2BAA4B,CAACH,EAAMC,IACxB,CAACX,EAAM7K,QAGlB2L,2BAA4B,CAACJ,EAAMC,KAC/B,IAAI9L,EAAO6L,EAAK7H,MAAM,KAAK,GAAGkI,QAAQ,IAAK,IAC3C,MAAO,CAAEf,EAAMtJ,QAAOxB,GAAKA,EAAEL,OAASA,IAAY,OAAC,EAGvDmM,uBAAyBN,IACrB,IAAI7L,EAAO6L,EAAK7H,MAAM,KAAK,GAAGkI,QAAQ,IAAK,IACvCE,EAAO,IAAIhD,EAAUpJ,GACrBkL,EAAQkB,EAAK7B,QAAU,IACvBY,EAAMnG,KAAKoH,GACXlB,GAASkB,EAAK7B,OAClB,EAGJ8B,mBAAoB,MLuDxB,WACI,IAAIC,EAAQ,GACRC,EAAa,GACbC,EAAa,GAEjB,IAAK,IAAItM,EAAI,EAAGA,EAAIsF,EAAQtF,IACxB,IAAK,IAAID,EAAI,EAAGA,EA1GZ,GA0GuBA,IACvBqM,EAAMtH,KAAK,CAAC/E,EAAGC,IAEX8F,EAAiB,EAAGsB,SAAS9B,IAAc8B,SAASmF,IAvG/C,GAuGqFnF,SAAS9B,IAAa,EAAG8B,SAAS9B,IAAc8B,SAASmF,IAAsBxM,EAAGC,IAC5KqM,EAAWvH,KAAK,CAAC/E,EAAGC,IAEpB8F,EAhHJ,GAgH4BsB,SAAS9B,IAAc8B,SAASmF,IAAsBC,GAAwBpF,SAAS9B,IAhHnH,GAgHuI8B,SAAS9B,IAAc8B,SAASmF,IAAsBxM,EAAGC,IAC5LsM,EAAWxH,KAAK,CAAC/E,EAAGC,KAIhCqF,EAAM,CACF+G,MAAOA,EAAOK,MAAOJ,EAAYK,MAAOJ,EAAYK,SAAUP,IAE9DA,MAAQ/G,EAAI+G,MAAMzK,QAAOxB,IAAMkF,EAAIoH,MAAM9K,QAAOqD,GAAKA,EAAE,KAAO7E,EAAE,IAAM6E,EAAE,KAAO7E,EAAE,KAAIC,SAAWiF,EAAIqH,MAAM/K,QAAOsD,GAAK9E,EAAE,KAAO8E,EAAE,IAAM9E,EAAE,KAAO8E,EAAE,KAAI7E,QAE9J,CK5EQwM,GACAC,GAAM5B,EAAK,EAGf6B,8BAAgCnB,IAC5BH,GAAwBG,GAG5BoB,wBAA0BpB,IACtBqB,GAAW,kBACX,IAAIC,EAAO,UAAa9M,GAAc,mBAATA,EAAE+M,KAAyB,GACpDC,EAAYF,EAAKG,QAAQC,WAAUlN,GAAgB,SAAXA,EAAEwL,OAC9CsB,EAAKG,QAAU,IACRnC,EAAM5F,KAAI,CAACiI,EAAGjF,KACV,CACHsD,KAAM,GAAGtD,EAAI,MAAMiF,EAAExN,OACrByN,SAAU,gCACVf,MAAO,IACPgB,OAAQ,MAEZP,EAAKG,QAAQD,GACjB,GAIR,IAAIM,GAAS,EACTC,GAAS,EAEb,SAASC,GAAOC,GACZ,OAAIA,EAAShK,SAAS,aACX6H,GAAYmC,GAAYnC,GAAYmC,GAAY,QAChDA,EAAShK,SAAS,UAEzBoJ,GADaY,EAAS9J,MAAM,KACV,IAEf,OACX,CAEA,SAASkJ,GAAWE,GAChB,aACA3B,GAAoB,EACpBF,GAAgB6B,EAChB,IAAI/B,EAAY0C,GAAaX,GAC7B,WACA9B,GAAWD,EAAUxJ,QAAOxB,GAAKA,EAAEwL,OAASL,KAAiB,EACjE,CAEA,SAASuC,GAAaC,GAClB,IACIC,EADOC,GAAQF,GACFV,QAAQzL,QAAOxB,GAAKA,EAAEoN,gBAA0BxD,IAAb5J,EAAEqN,QAAwBrN,EAAEqN,SAAWjC,MAI3F,OAHIwC,EAAM3N,OAAS,GAAyB,KAApBkL,KACpBA,GAAkByC,EAAM,GAAGpC,MAExBoC,CACX,CAEA,SAASC,GAAQd,GACb,IACI,OAAO,UAAa/M,GAAKA,EAAE+M,KAAOA,IAAI,EAC1C,CAAE,MAAQ,OAAO,IAAK,CAC1B,CAgDA,SAASe,GAAStC,EAAMuC,GACpB,IAAIC,EAAMxC,EAAK7H,MAAM,WACjB8H,EAAe,GACnB,IAAK,IAAIwC,KAAKD,EACVvC,EAAa9G,KAAK,IAAIsJ,MAE1B,IAAIC,EAASV,GAAOO,EAAPP,CAAiBhC,EAAMwC,GACpC,IAAK,IAAIG,KAAKD,EACV1C,EAAOA,EAAKK,QAAQJ,EAAa0C,GAAID,EAAOC,IAEhD,OAAO3C,CACX,CC/JA,IAAI4C,GAAU7N,KAAK8N,MACfC,GAAW/N,KAAK8N,MAEhBE,GAAc,GAEdC,GAAe,WAEfC,GAAU,CAAE7O,EAAG,EAAGC,EAAG,GAEzB,SAAS6O,GAAmBC,GACxBJ,GAActH,SAAS,IAAO0H,EAClC,CAEA,SAASC,KAEL,IAAI3L,GADJmL,GAAU7N,KAAK8N,OACOC,GAClBrL,GAASsL,KAWjB,SAAmBtL,GACM,aAAjBuL,GD+GR,SAAmBvL,GACV,IACD,EAAMxD,KAEVsL,EAAW5D,KAAK,EAAG,GACnB4D,EAAW/H,OAAOC,GAkBb,IACD,EAAM,IAAI4L,KAAKC,KAAK,EAAIC,QACxB,EAAIC,KAAOA,KAEX,EAAIC,SAAYC,IAEZ,IAAIpC,EAAOe,GAAQ3C,IACfF,EAAY8B,EAAKG,QAAQrI,MAAK,CAACC,EAAGC,SAAmB8E,IAAb9E,EAAEuI,OAAuBvI,EAAEuI,OAAS,EAAIxI,EAAEwI,cAAWzD,EAAY/E,EAAEwI,OAAS,IAEpH8B,EAAK5B,GAAS,GAClB,IAAK,IAAIrF,KAAK8C,EAAW,CACrB,IAAIoE,EAAOpE,EAAU9C,GAAGsD,KACpBP,EAAWD,EAAU9C,GACrBmH,EAAOD,IAASjE,GAAkB2B,EAAKwC,MAAMC,YAActE,EAASmC,SAAWN,EAAKwC,MAAME,gBAAkB1C,EAAKwC,MAAMG,MACvHC,EAAM,GAAGvE,KAAoBiE,EAAO,IAAM,MAAMA,IAAOjE,KAAoBiE,EAAO,IAAM,MACxFM,EAAIjM,SAAS,MAAQiM,EAAIjM,SAAS,MAAQwH,EAAS8C,WACnD2B,EAAM5B,GAAS4B,EAAKzE,EAAS8C,WAEjC,IAAI4B,EAAKT,EAAGU,QAAQ,CAAE7C,GAAI,UAAY7B,GAAgBkE,EAAOlH,EAAGsD,KAAMkE,EAAKG,KAAM,CAAEjQ,EAAG0N,GAAQzN,EAAGsP,EAAIhP,EAAG,GAAIC,EAAG,GAAKqE,MAAO4K,EAAMS,UAAWT,EAAMU,QAAS,cAEvJJ,EAAGK,SACC/E,EAASmC,WACTjC,GAAkBiE,GAGtBO,EAAGM,WACChF,EAASmC,WACTjC,GAAkBuE,EAClBlC,GAAOvC,EAASmC,SAAhBI,CAA0BvC,EAASO,OAG3C2D,GAAM,EACV,CAIA,GAHsB,mBAAlBjE,IACcgE,EAAGU,QAAQ,CAAE7C,GAAI,eAAgBvB,KAAM,kBAAmBqE,KAAM,CAAEjQ,EAAG0N,GAAQzN,EAAG0N,GAAS,GAAIpN,EAAG,IAAKC,EAAG,GAAKqE,MAAOqI,EAAKwC,MAAMG,MAAOK,UAAWhD,EAAKwC,MAAMG,MAAOM,QAAS,cAE1L1E,IAA2C,mBAAlBH,GAAoC,CAC7D,IAAI7D,EAAU,GACd8H,EAAK5B,GAAS,GACd,IAAI2C,EAAQ,GACRC,EAAW9E,GAAsB1H,MAAM,KAAK,GAAGyM,OAC/CC,EAAYpJ,SAASoE,GAAsB1H,MAAM,MAAQ,EACzD2M,EAAaxF,EAAMuF,GAAWlG,wBAE9BoG,GADarB,EAAGU,QAAQ,CAAE7C,GAAI,cAAevB,KAAM,GAAG2E,8BAAqCG,IAAcT,KAAM,CAAEjQ,EAAGsQ,EAAOrQ,EAAG0N,GAAS,GAAIpN,EAAG,IAAKC,EAAG,GAAKqE,MAAOqI,EAAKwC,MAAMG,MAAOK,UAAWhD,EAAKwC,MAAMG,MAAOM,QAAS,cAC9M,UAAiB/P,GAAKA,EAAEwQ,WAAW/M,SAAS0M,MAC5D,IAAK,IAAIpI,KAAKwI,EAAW,CACrB,IAAIE,EAAQF,EAAUxI,GAClB2I,EAAW5F,EAAMuF,GAAWlH,UAAU3H,QAAOxB,GAAKyQ,EAAM9Q,OAASK,EAAEL,OACnE0P,EAAOvC,EAAKwC,MAAME,gBAClBkB,EAASzQ,OAAS,IAClBoP,EAAOvC,EAAKwC,MAAMqB,UAGtB,IAAIhB,EAAKT,EAAGU,QAAQ,CAAE7C,GAAI,WAAa7B,GAAgBuF,EAAM9Q,KAAOoI,EAAGyD,KAAMiF,EAAM9Q,KAAMkQ,KAAM,CAAEjQ,EAAGsQ,EAAOrQ,EAAGsP,EAAIhP,EAAG,IAAKC,EAAG,GAAKqE,MAAO4K,EAAMS,UAAWT,EAAMU,QAAS,cAEzK,GAAIJ,EAAGK,QAAS,CACZ,IAAIY,EAAO,CAAC,YAAYH,EAAMI,UAAW,WAAWJ,EAAMK,SAAU,UAAUL,EAAMM,QAAS,SAASN,EAAMO,QACxGP,EAAMQ,QACNL,EAAKjM,KAAK,mBAEd0C,EAAUuJ,EAAKM,KAAK,KACxB,CACIvB,EAAGM,YACCS,EAASzQ,OAAS,GAClB6K,EAAMuF,GAAWlH,UAAY2B,EAAMuF,GAAWlH,UAAU3H,QAAOxB,GAAKA,EAAEL,OAAS8Q,EAAM9Q,OACrFmL,EAAMuF,GAAWlG,sBAAsBmG,EAAaG,EAAMO,OAEtDV,EAAaG,EAAMO,MAAQ,IAC3BlG,EAAMuF,GAAWlH,UAAUxE,KAAK8L,GAChC3F,EAAMuF,GAAWlG,sBAAsBmG,EAAaG,EAAMO,QAKtE7B,GAAM,GACFA,EAAK,MACLA,EAAK5B,GAAS,GACd2C,GAAS,GAEjB,CAEI7I,IACA6H,EAAGiC,cAAc,cACPjC,EAAGU,QAAQ,CAAE7C,GAAI,aAAcvB,KAAMnE,EAASzH,EAAG6O,GAAQ7O,EAAGC,EAAG4O,GAAQ5O,EAAI,EAAGuR,UAAU,EAAM3M,MAAOqI,EAAKwC,MAAME,gBAAiBM,UAAWhD,EAAKwC,MAAMC,YAAaQ,QAAS,cAE/L,IAGR,EAAI7I,MAxGR,CCrHQ,CAAajE,GACW,SAAjBuL,IJhCf,SAAmBvL,GACV,IACD,EAAMxD,KAEV,EAAI4R,UAAU,EAAG,EAAG,IAAK,KFiD7B,SAAiBpO,GACb,IAAI3D,EAAMG,IACVH,EAAIgS,OAEJhS,EAAIiS,WAAWhM,EAAO3F,GAAI2F,EAAO1F,GAEjCH,EAAU,aAAc,EAAG,GAE3B,IAAI8R,EAAKlS,EAAImS,YACbnS,EAAImS,YAAcrM,EAClB,IAAI6G,EAAQ/G,EAAI+G,MAChB,IAAK,IAAI1J,KAAK0J,EAGVvM,EAAU,aAFFuM,EAAM1J,GAAG,GAAKiD,EACdyG,EAAM1J,GAAG,GAAKiD,GAI1B,IAAK,IAAIjD,KAAK2C,EAAIoH,MAGd5M,EAAU,cAFFwF,EAAIoH,MAAM/J,GAAG,GAAKiD,EAClBN,EAAIoH,MAAM/J,GAAG,GAAKiD,GAG9B,IAAK,IAAIjD,KAAK2C,EAAIqH,MAGd7M,EAAU,cAFFwF,EAAIqH,MAAMhK,GAAG,GAAKiD,EAClBN,EAAIqH,MAAMhK,GAAG,GAAKiD,GAG9BlG,EAAImS,YAAcD,EAEdnM,IACAqB,QAAQC,IAAI,gBAAiBtB,GAC7BA,EAAczF,EAAI6O,GAAQ7O,EAC1ByF,EAAcxF,EAAI4O,GAAQ5O,EAC1BwF,EAAc8B,KAAKlE,IAGvB3D,EAAIoS,SACR,CEpFIC,CAAQ1O,GAoBHmE,IACDA,EAAM,IAAIyH,KAAKC,KAAK,EAAIC,QACxB3H,EAAI4H,KAAOA,KAEX5H,EAAI6H,SAAYC,IACZ,IAAI7K,EAAQY,IAAe2M,MAAM,EAAG,GAAGC,cAAgB5M,IAAe2M,MAAM,GAC5E1C,EAAGU,QAAQ,CAAE7C,GAAI,WAAYvB,KAAM,GAAGnH,MAAUW,IAAcrF,OAAQkQ,KAAM,CAAEjQ,EAAG,GAAIC,EAAG,EAAGM,EAAG,IAAKC,EAAG,GAAKqE,MAAO,YAAaA,MAAO,YAAasL,QAAS,cAE5Jb,EAAGU,QAAQ,CAAE7C,GAAI,aAAcvB,KAAMnE,EAASwI,KAAM,CAAEjQ,EAAG,EAAGC,EAAG,EAAGM,EAAG,IAAKC,EAAG,IAAMqE,MAAO,YAAaqL,UAAW,YAAaC,QAAS,aAAa,GAG7J3I,EAAIF,MA5BR,CIwBQ,CAASjE,EAEjB,CAhBQ,CAAUA,GACVqL,GAAWF,IAEfhG,OAAOwG,sBAAsBA,GACjC,CAcA9M,eAAegQ,WVIf,WACI,IAAIC,EAAW,GACf,IAAK,IAAI7J,KAAK,EAAQ,CAClB,IAAIhI,EAAQ,EAAOgI,GACnB6J,EAASpN,KAAK,IAAI3C,SAAQ,CAACC,EAASC,KAAW8P,OAxBpCC,EAwB8C/R,EAAM+R,SAvB5D,IAAIjQ,SAAQ,CAACC,EAASC,KACzB,IAAInC,EAAM,IAAImS,MACdnS,EAAIoS,OAAUpK,IACV9F,EAAQlC,EAAG,EAEfA,EAAIqS,QAAWrK,IACXrB,QAAQ0C,MAAM,uBAAuB6I,KAAalK,GAClD7F,EAAO,KAAI,EAEH,UAAclC,GAAKA,EAAEiS,WAAaA,IACpChS,OAAS,EACfF,EAAIsS,IAAMJ,GAEVvL,QAAQ0C,MAAM,sCAAsC6I,gBACpD/P,EAAO,MACX,KAQyEoQ,MAAKrE,IAC1E/N,EAAMA,MAAQ+N,EACdhM,EAAQgM,EAAC,IACVsE,OAAMxK,GAAKrB,QAAQ0C,MAAM,iBAAkBlJ,EAAM+R,SAAUlK,KA3BtE,IAAmBkK,CA2BsD,IACrE,CACA,OAAOjQ,QAAQwQ,WAAWT,EAC9B,CUbUU,GAEN,IAAI1D,EAAS2D,SAASC,eAAe,cACjCC,EAAQ7D,EAAO1C,MAAQ0C,EAAO5J,OAClC4J,EAAO8D,MAAM1N,OAASiD,OAAO0K,YAAc,KAC3C/D,EAAO8D,MAAMxG,MAAQjE,OAAO0K,YAAcF,EAAQ,KAClDxK,OAAOE,iBAAiB,UAAU,KAC9ByG,EAAO8D,MAAM1N,OAASiD,OAAO0K,YAAc,KAC3C/D,EAAO8D,MAAMxG,MAAQjE,OAAO0K,YAAcF,EAAQ,QAGtD7D,EAAOzG,iBAAiB,aAAcP,IAClC0G,GAAQ7O,EAAIqH,UAAUc,EAAEgL,QAAUhE,EAAOiE,aAAejE,EAAO1C,MAAQpF,SAAS8H,EAAO8D,MAAMxG,SAAW,EACxGoC,GAAQ5O,EAAIoH,UAAUc,EAAEkL,QAAUlE,EAAOmE,YAAcnE,EAAO5J,OAAS8B,SAAS8H,EAAO8D,MAAM1N,SAAQ,IAGzG4J,EAAOzG,iBAAiB,eAAgBP,IACpCA,EAAEoL,kBACK,KAGXzE,GAAmB,IACnBnP,EAAWwP,EAAOtP,WAAW,OD6C7B,WAEA,WAAe,YAAY,KAChBoO,GAAQ3C,IACfF,EAAY0C,GAAaxC,IACzBD,GAAWD,EAAUxJ,QAAOxB,GAAKA,EAAEwL,OAASL,KAAiB,GAC7D,IAAIiI,EAAQpI,EAAUkC,WAAUlN,GAAKA,EAAEwL,OAASL,KAChDiI,IACIA,GAASpI,EAAU/K,SACnBmT,EAAQ,GAEZjI,GAAkBH,EAAUoI,GAAO5H,QAEvC,WAAe,UAAU,KACdqC,GAAQ3C,IACfF,EAAY0C,GAAaxC,IACzBD,GAAWD,EAAUxJ,QAAOxB,GAAKA,EAAEwL,OAASL,KAAiB,GAC7D,IAAIiI,EAAQpI,EAAUkC,WAAUlN,GAAKA,EAAEwL,OAASL,KAChDiI,IACIA,EAAQ,IACRA,EAAQpI,EAAU/K,OAAS,GAE/BkL,GAAkBH,EAAUoI,GAAO5H,QAEvC,WAAe,UAAU,KACdqC,GAAQ3C,IACfF,EAAY0C,GAAaxC,IACzB,KACID,GAAWD,EAAUxJ,QAAOxB,GAAKA,EAAEwL,OAASL,KAAiB,IAChDiC,UACTI,GAAOvC,GAASmC,SAAhBI,CAA0BvC,GAASO,KAE3C,CAAE,MAAO,KCzEbpD,OAAOwG,sBAAsBA,GACjC,CAEA9M,eAAe4K,GAAM5B,GAEjB,aACA,IAAIiE,EAAS2D,SAASC,eAAe,cACrCnE,GAAe,OAEflK,EAAQ,aAAc,QACtBA,EAAQ,aAAc,OAEtB,IAAK,IAAI+O,KAAKvI,EACV3E,EAAQ,aAAc2E,EAAMuI,IAGhC3E,GAAmB,IACnBnP,EAAWwP,EAAOtP,WAAW,OJ3D7B6H,II+DAc,OAAOwG,sBAAsBA,GACjC,C","sources":["webpack://tactics/webpack/universalModuleDefinition","webpack://tactics/webpack/bootstrap","webpack://tactics/webpack/runtime/define property getters","webpack://tactics/webpack/runtime/hasOwnProperty shorthand","webpack://tactics/webpack/runtime/make namespace object","webpack://tactics/./src/images.js","webpack://tactics/./src/sprites.js","webpack://tactics/./src/grammar.js","webpack://tactics/./src/teams.js","webpack://tactics/./src/map.js","webpack://tactics/./src/actor.js","webpack://tactics/./src/mainScene.js","webpack://tactics/./src/input.js","webpack://tactics/./src/character.js","webpack://tactics/./src/menuScene.js","webpack://tactics/./src/main.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tactics\"] = factory();\n\telse\n\t\troot[\"tactics\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import images from './images.json'\r\n\r\nvar ctx = null\r\n\r\nfunction setContext(context) {\r\n    ctx = context\r\n}\r\n\r\nfunction getContext() {\r\n    return ctx\r\n}\r\n\r\nfunction getImage(name) {\r\n    let img = images.filter(f => f.name === name)\r\n    return img.length > 0 ? img[0].image : null\r\n}\r\n\r\nfunction getImages() {\r\n    return images\r\n}\r\n\r\nfunction drawImage(name, x, y, srcRect) {\r\n    let img = images.filter(f => f.name === name)\r\n    if (img.length > 0) {\r\n        if (srcRect) {\r\n            ctx.drawImage(img[0].image, srcRect.x, srcRect.y, srcRect.w, srcRect.h, x, y, srcRect.w, srcRect.h)\r\n        } else {\r\n            ctx.drawImage(img[0].image, x, y)\r\n        }\r\n    }\r\n}\r\n\r\nfunction loadImage(filename) {\r\n    return new Promise((resolve, reject) => {\r\n        let img = new Image()\r\n        img.onload = (e) => {\r\n            resolve(img)\r\n        }\r\n        img.onerror = (e) => {\r\n            console.error(`Failed to load file ${filename}:`, e)\r\n            reject(null)\r\n        }\r\n        let image = images.filter(f => f.filename === filename)\r\n        if (image.length > 0) {\r\n            img.src = filename\r\n        } else {\r\n            console.error(`Image definition matching filename ${filename} not found.`)\r\n            reject(null)\r\n        }\r\n    })\r\n}\r\n\r\nfunction loadAllImages() {\r\n    let promises = []\r\n    for (let i in images) {\r\n        let image = images[i]\r\n        promises.push(new Promise((resolve, reject) => loadImage(image.filename).then(r => {\r\n            image.image = r\r\n            resolve(r)\r\n        }).catch(e => console.error('Failed to load', image.filename, e))))\r\n    }\r\n    return Promise.allSettled(promises)\r\n}\r\n\r\nexport { loadAllImages, loadImage, drawImage, getImage, getImages, setContext, getContext }\r\n","import { drawImage, getImages } from './images.js'\r\nimport animations from './sprites.json'\r\n\r\nfunction lerp (start, end, amt){\r\n    return (1-amt)*start+amt*end\r\n  }\r\n  function lerpCoords (start, end, amt){\r\n    return { x: (1-amt)*start.x+amt*end.x, y: (1-amt)*start.y+amt*end.y }\r\n  }\r\n\r\nfunction removeSprite(name) {\r\n    let index = sprites.findIndex(f => f.name === name)\r\n    if (index >= 0) {\r\n        sprites[index] = undefined\r\n    }\r\n    sprites = sprites.filter(f => f !== undefined)\r\n}\r\n\r\nfunction getMsSinceMidnight(d) {\r\n    var e = new Date(d);\r\n    return d - e.setHours(0,0,0,0)\r\n    }\r\n\r\nfunction buildSprite(name, x, y, pose, onComplete) {\r\n    if (!animations[name]) {\r\n        throw new Error(`Can't build sprite, missing animation definition '${name}'.`)\r\n    }\r\n    let sprite = {\r\n        name: name,\r\n        x: x, y: y,\r\n        frames: [],\r\n        pose: pose,\r\n        framesImage: null,\r\n        currentFrame: 0,\r\n        updateDelta: 0,\r\n        play: true\r\n    }\r\n    sprite.SetAnimation = (animation, pose, onComplete) => {\r\n        sprite.animStartTime = getMsSinceMidnight(new Date())\r\n        let anim = animations[animation]\r\n        if (onComplete) {\r\n            sprite.onComplete = onComplete\r\n        }\r\n        if (anim) {\r\n            let sprPose = anim.default ? anim.default : null\r\n            sprPose = anim[pose] ? anim[pose] : sprPose\r\n            if (sprPose) {\r\n                let img = getImages().filter(f => f.name === sprPose.imageName)\r\n                if (img.length > 0) {\r\n                    sprite.frames = sprPose.frames\r\n                    sprite.currentFrame = 0\r\n                    sprite.animation = animation\r\n                    sprite.pose = pose\r\n                    sprite.framesImage = sprPose.imageName\r\n                    if (sprPose.sfx) {\r\n                        let sfx = getSfx(sprPose.sfx)\r\n                        if (sfx) {\r\n                            sfx.play()\r\n                        }\r\n                    }\r\n                } else {\r\n                    throw new Error(`Can't find pose ${pose} in ${animation}.`)\r\n                }\r\n            } else {\r\n                sprite.frames = []\r\n                sprite.currentFrame = 0\r\n                sprite.animation = ''\r\n                sprite.pose = ''\r\n            }\r\n            sprite.play = true\r\n        }\r\n    }\r\n    sprite.draw = (offsetx, offsety) => {\r\n        offsetx = offsetx ? offsetx : 0\r\n        offsety = offsety ? offsety : 0\r\n        drawImage(sprite.framesImage, sprite.x + offsetx, sprite.y + offsety, sprite.frames[sprite.currentFrame])\r\n    }\r\n    sprite.moveTo = async (x, y, speed) => {\r\n        return new Promise(async (resolve, reject) => {\r\n            let spr = sprite\r\n            let ox = spr.x\r\n            let oy = spr.y\r\n            let spd = speed\r\n            let t = 0\r\n            let move = (mx, my) => new Promise((resolve, reject) => {\r\n                let handler = () => {\r\n                    t += spd\r\n                    if (t >= 1) {\r\n                        spr.x = x\r\n                        spr.y = y\r\n                        resolve()\r\n                    } else {\r\n                        let p = lerpCoords({ x: ox, y: oy }, { x: mx, y: my }, t)\r\n                        spr.x = p.x\r\n                        spr.y = p.y\r\n                        setTimeout(handler, 16)\r\n                    }\r\n                }\r\n                setTimeout(handler, 16)\r\n            })\r\n    \r\n            await move(x, y)\r\n            resolve()\r\n        })\r\n    }\r\n    sprite.onComplete = onComplete ? onComplete : (sprite) => {}\r\n    sprite.update = (delta) => {\r\n        let sprPose = animations[sprite.animation][sprite.pose]\r\n        if (sprPose && sprite.play) {\r\n            if (sprite.updateDelta > sprPose.frameDelay) {\r\n                sprite.currentFrame++\r\n                if (sprite.currentFrame > sprite.frames.length - 1) {\r\n                    if (sprPose.repeat) {\r\n                        sprite.currentFrame = 0\r\n                        sprite.animDuration = getMsSinceMidnight(new Date()) - sprite.animStartTime\r\n                        sprite.onComplete(sprite)\r\n                    } else {\r\n                        sprite.animDuration = getMsSinceMidnight(new Date()) - sprite.animStartTime\r\n                        sprite.currentFrame--\r\n                        sprite.play = false\r\n                        sprite.onComplete(sprite)\r\n                    }\r\n                    if (sprPose.onComplete) {\r\n                        sprPose.onComplete(sprite)\r\n                    }\r\n                }\r\n                sprite.updateDelta = 0\r\n            } else {\r\n                sprite.updateDelta += delta\r\n            }\r\n        }\r\n    }\r\n    sprite.SetAnimation(name, pose)\r\n\r\n    return sprite\r\n}\r\n\r\nfunction getAnimation(animation) {\r\n    try {\r\n        return animations[animation]\r\n    } catch {}\r\n    return {}\r\n}\r\n\r\nexport { buildSprite, removeSprite, getAnimation, getMsSinceMidnight }","let grammar = {}\r\n\r\nfunction randInt(min, max) {\r\n    //return Math.floor(ROT.RNG.getUniform() * (max - min + 1) + min)\r\n    return Math.floor(Math.random() * (max - min + 1) + min)\r\n  }\r\n\r\nfunction roll(dice) {\r\n    dice = dice.toLowerCase();\r\n    if (!dice.includes('d')) {\r\n        throw new Error('At least one term must specify the number of dice.')\r\n    } else {\r\n        let dieterm = dice.split('d')\r\n        let amt = 0\r\n        for (let times = 0; times < dieterm[0]; times++) {\r\n            amt += randInt(1, dieterm[1])\r\n        }\r\n        return amt\r\n    }\r\n}\r\n\r\n/**\r\n * The value for the key specified as the id parameter. Value is either an array of strings or a string reference to an array of strings.\r\n * @param {string} id \r\n * @returns {string|array} Returns either the value of the key matching 'id', or an empty string.\r\n */\r\nfunction get(id) {\r\n    if (!id) {\r\n        return ''\r\n    }\r\n    if (typeof id === 'string') {\r\n        id = id.replace('[*', '').replace(']', '')\r\n    }\r\n    let item = grammar[id]\r\n    if (item) {\r\n        if (typeof item === 'string') {\r\n            return item\r\n        } else if (typeof item === 'object') {\r\n            return item[randInt(0, item.length - 1)]\r\n        }\r\n    }\r\n    return id //`[not found:${id}]`\r\n}\r\n\r\n/**\r\n * Set the value for the key specified as the id parameter. Value is either an array of strings or a string reference to an array of strings.\r\n * @param {string} id \r\n * @param {string|array} value \r\n */\r\nfunction set(id, value) {\r\n    grammar[id] = value\r\n}\r\n\r\n/**\r\n * Processes any operators on the text about to be added to the sentence chain.\r\n * @param {string} txt \r\n * @param {string} operator \r\n * @returns \r\n */\r\nfunction operatorText(txt, operator) {\r\n    if (operator === 'capital') {\r\n        txt = txt.charAt(0).toUpperCase() + txt.slice(1)\r\n    }\r\n    return txt\r\n}\r\n\r\nfunction parseTokens(template, context) {\r\n    if (template.includes('[')) {\r\n        let startPos = 0\r\n        let tokenMap = []\r\n        while(template.includes('[', startPos)) {\r\n            let paramStart = template.indexOf('[', startPos)\r\n            if (paramStart > startPos) {\r\n                tokenMap.push({ start: startPos, end: paramStart, token: null, value: template.substring(startPos, paramStart) })    \r\n            }\r\n            let paramEnd = template.indexOf(']', startPos)\r\n            let token = template.substring(paramStart, paramEnd + 1)\r\n            tokenMap.push({ start: paramStart, end: paramEnd, token: token, value: null })\r\n            startPos = paramEnd + 1\r\n        }\r\n        if (startPos < template.length) {\r\n            tokenMap.push({ start: startPos, end: template.length - 1, token: null, value: template.substring(startPos, template.length)})\r\n        }\r\n        return tokenMap\r\n    } else {\r\n        return [template]\r\n    }\r\n}\r\n\r\nfunction compareOperation(property, operation, operator, value) {\r\n    if (operation === \"is\") {\r\n        if (operator === '=') {\r\n            return property === value\r\n        }\r\n    } else if (operation === \"has\") {\r\n        if (operator === \"=\") {\r\n            return property[value] !== undefined\r\n        }\r\n    } else {\r\n        if (typeof property === 'object' && [\"=\", \"!=\", \">=\", \"<=\", \"<\", \">\"].includes(operator)) {\r\n            if ([\"=\", \"!=\"].includes(operator)) {\r\n                return operator === \"=\" ? property[operation] === value : property[operation] !== value\r\n            } else if ([\">=\", \"<=\"].includes(operator)) {\r\n                return operator === \">=\" ? property[operation] >= value : property[operation] <= value\r\n            } else if ([\">\", \"<\"].includes(operator)) {\r\n                return operator === \">\" ? property[operation] > value : property[operation] < value\r\n            }            \r\n        } else if (typeof property === 'number' && [\"=\", \"!=\", \">=\", \"<=\", \"<\", \">\"].includes(operator)) {\r\n            if ([\"=\", \"!=\"].includes(operator)) {\r\n                return operator === \"=\" ? property === value : property !== value\r\n            } else if ([\">=\", \"<=\"].includes(operator)) {\r\n                return operator === \">=\" ? property >= value : property <= value\r\n            } else if ([\">\", \"<\"].includes(operator)) {\r\n                return operator === \">\" ? property > value : property < value\r\n            }            \r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nfunction process(template, context) {\r\n    if (!template.includes('[')) {\r\n        return {\r\n            'tokenmap': {},\r\n            'sentence': template,\r\n            'sentenceHTML': template\r\n        }\r\n    }\r\n    context = context ? context : {}\r\n    let tokenMap = processTokenMap(parseTokens(template, context), context)\r\n    let sentence = ''\r\n    let sentenceHTML = ''\r\n    let map = tokenMap\r\n    for (let m in map) {\r\n        if (m > 0) {\r\n            let prev = map[m - 1]\r\n            if ((prev.token_type === 'condition' && prev.token_result) || (prev.token_type !== 'condition' && map[m].value)) {\r\n                if (map[m].token) {\r\n                    prev.value = map[m].value\r\n                    sentenceHTML += `<mark title='${m > 0 ? JSON.stringify(prev) : map[m].token}'>${map[m].value}</mark>`\r\n                    sentence += map[m].value\r\n                } else {\r\n                    sentenceHTML += map[m].value\r\n                    sentence += map[m].value\r\n                }\r\n            }\r\n        } else {\r\n            if (map[m].token && map[m].value) {\r\n                sentenceHTML += `<mark title='${map[m].token}'>${map[m].value}</mark>`\r\n                sentence += map[m].value\r\n            } else if (map[m].value) {\r\n                    sentenceHTML += map[m].value\r\n                    sentence += map[m].value\r\n            }\r\n        }\r\n    }\r\n    if (!sentence.includes('[')) {\r\n        return {\r\n            'tokenmap': tokenMap,\r\n            'sentence': sentence,\r\n            'sentenceHTML': sentenceHTML\r\n        }\r\n    } else {\r\n        return process(sentence, context)\r\n    }\r\n}\r\n\r\nfunction processTokenMap(tokenMap, context) {\r\n    let activeConditional = -1\r\n    for (let t in tokenMap) {\r\n        if (tokenMap[t].value === null) {\r\n            if (tokenMap[t].token) {\r\n                if (tokenMap[t].token.substring(0, 2) === '[*') {\r\n                    tokenMap[t].token_type = 'lookup'\r\n                    let id = tokenMap[t].token.substring(2, tokenMap[t].token.length - 1)\r\n                    if (!id.includes('[')) {\r\n                        tokenMap[t].value = get(id)\r\n                    }\r\n                } else if (tokenMap[t].token.substring(0, 2) === '[?') {\r\n                    tokenMap[t].token_type = 'condition'\r\n                    activeConditional = t\r\n                    let id = tokenMap[t].token.substring(2, tokenMap[t].token.length - 1)\r\n                    let paths = id.split('.')\r\n\r\n                    let room = null\r\n                    if (context.room) {\r\n                        room = rooms.getRoom(context.room)\r\n                    }\r\n\r\n                    if (paths.length === 3) {\r\n                        let contextName = paths[0]\r\n                        let contextProperty = paths[1]\r\n                        let comparison = paths[2]\r\n\r\n                        if (contextName === 'room' && room) {\r\n                            if (room[contextProperty]) {\r\n                                let comp = comparison.search(/[(=)(!=)(<)(>)(>=)(<=)]/)\r\n                                if (comp >= 0) {\r\n                                    let operation = comparison.substring(0, comp)\r\n                                    let opEnd = comparison.slice(comp).search(/[A-Za-z0-9_-]/)\r\n                                    if (opEnd < 0) {\r\n                                        opEnd = 1\r\n                                    }\r\n                                    let operator = comparison.substring(comp, comp + opEnd)\r\n                                    let value = comparison.substring(comp + 1, comparison.length)\r\n                                    tokenMap[t].token_operation = operation\r\n                                    tokenMap[t].token_operator = operator\r\n                                    tokenMap[t].token_compare_to = value\r\n                                    tokenMap[t].token_property = room[contextProperty]\r\n                                    tokenMap[t].token_result = compareOperation(room[contextProperty], operation, operator, value)\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (paths.length === 1) {\r\n                        // If there's no path, try a die roll notation.\r\n                        let comparison = paths[0]\r\n                        let comp = comparison.search(/[(=)(!=)(<)(>)(>=)(<=)]/)\r\n                        if (comp >= 0) {\r\n                            let operation = comparison.substring(0, comp)\r\n                            let opEnd = comparison.slice(comp).search(/[A-Za-z0-9_-]/)\r\n                            if (opEnd < 0) {\r\n                                opEnd = 1\r\n                            }\r\n                            let operator = comparison.substring(comp, comp + opEnd)\r\n                            let value = parseInt(comparison.substring(comp + 1, comparison.length))\r\n                            let rl = roll(operation)\r\n                            tokenMap[t].die_roll = rl\r\n                            tokenMap[t].token_operation = operation\r\n                            tokenMap[t].token_operator = operator\r\n                            tokenMap[t].token_compare_to = value\r\n                            tokenMap[t].token_property = rl\r\n                            tokenMap[t].token_result = compareOperation(rl, operation, operator, value)\r\n                        }\r\n                    }\r\n                } else if (tokenMap[t].token.toLowerCase() === \"[else]\") {\r\n                    if (activeConditional >= 0) {\r\n                        tokenMap[t].token_operation = tokenMap[activeConditional].token_operation\r\n                        tokenMap[t].token_operator = tokenMap[activeConditional].token_operator\r\n                        tokenMap[t].token_compare_to = tokenMap[activeConditional].token_compare_to\r\n                        tokenMap[t].token_property = tokenMap[activeConditional].token_property\r\n                        tokenMap[t].token_type = 'condition'\r\n                        tokenMap[t].token_result = !compareOperation(tokenMap[t].token_property, tokenMap[t].token_operation, tokenMap[t].token_operator, tokenMap[t].token_compare_to)\r\n                        activeConditional = -1\r\n                    }\r\n                } else if (tokenMap[t].token.substring(0, 1) === '[') {\r\n                    tokenMap[t].value = tokenMap[t].token.replace('[', '').replace(']', '')\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return tokenMap\r\n}\r\n\r\n/**\r\n * Get the generated text of the specified template text.\r\n * @param {string} template Template text to generate from the dictionary.\r\n * @param {object} context JSON containing the list of contexts and their objects to execute under.\r\n * @returns {string} Evaluated text result.\r\n */\r\nfunction text(template, context) {\r\n    let sentence = []\r\n    let startPos = 0\r\n    // If there are any tokens to process in this template.\r\n    if (template.includes('[')) {\r\n        let paramStart = 0\r\n        let paramEnd = template.indexOf('[')\r\n        while(template.includes('[', startPos)) {\r\n            paramStart = template.indexOf('[', startPos)\r\n            paramEnd = template.indexOf(']', startPos)\r\n            //sentence.push(template.substring(startPos, paramStart))\r\n            let id = template.substring(paramStart, paramEnd + 1)\r\n            \r\n            let operator\r\n            if (id.includes('.')) {\r\n                let parts = id.split('.')\r\n                id = parts[0] + ']'\r\n                operator = parts[1].toLowerCase().substring(0, parts[1].length - 1)\r\n            }\r\n            if (id !== template) {\r\n                let txt = text(id)\r\n                sentence.push(txt)\r\n            } else {\r\n                let txt = get(id)\r\n                sentence.push(txt)\r\n            }\r\n            startPos = paramEnd + 1\r\n        }\r\n        if (startPos < template.length) {\r\n            sentence.push(template.substring(startPos, template.length))\r\n        }\r\n    } else {\r\n        let id = get(template)\r\n        return id ? id : `[not found:${id}]` \r\n    }\r\n\r\n    let ret = sentence.reduce((prev, next) => prev + next)\r\n    return ret.includes('[*') ? text(ret) : ret\r\n}\r\n\r\n/**\r\n * Sets the whole dictionary object to the json parameter.\r\n * @param {object} json \r\n */\r\nfunction setDictionary(json) {\r\n    grammar = json\r\n}\r\n\r\n/**\r\n * Loads the dictionary from a file buffer.\r\n * @param {buffer} buffer \r\n */\r\nfunction loadDictionary(buffer) {\r\n    grammar = JSON.parse(buffer.toString())\r\n}\r\n\r\nexport { loadDictionary, setDictionary, text, set, get, roll, randInt }","import { roll } from './grammar.js'\r\n\r\nvar teams = []\r\nvar teamIndex = 0\r\nvar phases = ['positioning', 'movement', 'active', 'siege', 'upkeep']\r\nvar phase = 0\r\n\r\nfunction addTeam(name, turnOrderRollDice) {\r\n    let team = {\r\n        name: name,\r\n        color: '#ccccccff',\r\n        order: roll(turnOrderRollDice)\r\n    }\r\n    teams.push(team)\r\n    teams.sort((a, b) => b.order - a.order)\r\n    return team\r\n}\r\n\r\nfunction getTeam(name) {\r\n    let team = teams.filter(f => f.name === name)\r\n    return team.length > 0 ? team[0] : null\r\n}\r\n\r\nfunction currentTeam() {\r\n    return teams[teamIndex]\r\n}\r\n\r\nfunction currentPhase() {\r\n    return phases[phase]\r\n}\r\n\r\nfunction nextPhase() {\r\n    phase++\r\n    phase = phase >= phases.length ? 0 : phase\r\n}\r\n\r\nfunction nextTeam() {\r\n    teamIndex++\r\n    teamIndex = teamIndex >= teams.length ? 0 : teamIndex\r\n}\r\n\r\nexport { addTeam, currentTeam, currentPhase, nextPhase, getTeam, nextTeam }","import Actor from \"./actor.js\"\r\nimport { getContext, drawImage } from \"./images.js\"\r\nimport { getTeam } from \"./teams.js\"\r\nimport { pointer } from \"./main.js\"\r\n\r\nvar map = null\r\n\r\nvar width = 36\r\nvar height = 24\r\n\r\nvar gridSize = 24\r\nvar gridOpacity = 0.3\r\n\r\nvar startAreaWidth = 10\r\nvar startAreaHeight = 24\r\n\r\nvar placingSprite = null\r\n\r\nvar units = []\r\n\r\nvar camera = {\r\n    x: 24,\r\n    y: 8.5 * gridDimensions,\r\n    w: 320 / gridDimensions, h: 200 / gridDimensions,\r\n    targetX: 0,\r\n    targetY: 8.5 * gridDimensions,\r\n}\r\n\r\nfunction setPlacingSprite(sprite) {\r\n    placingSprite = sprite\r\n}\r\n\r\nfunction triangleContains(ax, ay, bx, by, cx, cy, x, y) {\r\n\r\n    let det = (bx - ax) * (cy - ay) - (by - ay) * (cx - ax)\r\n\r\n    return  det * ((bx - ax) * (y - ay) - (by - ay) * (x - ax)) >= 0 &&\r\n            det * ((cx - bx) * (y - by) - (cy - by) * (x - bx)) >= 0 &&\r\n            det * ((ax - cx) * (y - cy) - (ay - cy) * (x - cx)) >= 0    \r\n\r\n}\r\n\r\nfunction addUnit(teamName, unit) {\r\n    let actor = new Actor({\r\n        team: getTeam(teamName),\r\n        name: unit.name,\r\n        character: unit,\r\n        spriteName: 'player',\r\n        x: 0,\r\n        y: 0\r\n    })\r\n    units.push(actor)\r\n    return actor\r\n}\r\n\r\nfunction getUnits(teamName) {\r\n    console.log(teamName, units)\r\n    if (teamName) {\r\n        return units.filter(f => f.team.name === teamName)\r\n    } else {\r\n        return units\r\n    }\r\n}\r\n\r\nfunction drawMap(delta) {\r\n    let ctx = getContext()\r\n    ctx.save()\r\n\r\n    ctx.translate(-camera.x, -camera.y)\r\n\r\n    drawImage('mars-scape', 0, 0)\r\n\r\n    let ga = ctx.globalAlpha\r\n    ctx.globalAlpha = gridOpacity\r\n    let tiles = map.tiles\r\n    for (let t in tiles) {\r\n        let x = tiles[t][0] * gridDimensions\r\n        let y = tiles[t][1] * gridDimensions\r\n        drawImage('grid-white', x, y)\r\n    }\r\n\r\n    for (let t in map.teamA) {\r\n        let x = map.teamA[t][0] * gridDimensions\r\n        let y = map.teamA[t][1] * gridDimensions\r\n        drawImage('grid-yellow', x, y)\r\n    }\r\n    for (let t in map.teamB) {\r\n        let x = map.teamB[t][0] * gridDimensions\r\n        let y = map.teamB[t][1] * gridDimensions\r\n        drawImage('grid-yellow', x, y)\r\n    }\r\n    ctx.globalAlpha = ga\r\n\r\n    if (placingSprite) {\r\n        console.log('placingSprite', placingSprite)\r\n        placingSprite.x = pointer.x\r\n        placingSprite.y = pointer.y\r\n        placingSprite.draw(delta)\r\n    }\r\n\r\n    ctx.restore()\r\n}\r\n\r\nfunction gridDimensions() {\r\n    return { x: gridDimensions, y: gridDimensions }\r\n}\r\n\r\nfunction buildMap() {\r\n    var tiles = []\r\n    var teamATiles = []\r\n    var teamBTiles = []\r\n\r\n    for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n            tiles.push([x, y])\r\n            \r\n            if (triangleContains(0, parseInt(height / 2) - parseInt(startAreaHeight / 2), startAreaWidth, parseInt(height / 2), 0, parseInt(height / 2) + parseInt(startAreaHeight / 2), x, y)) {\r\n                teamATiles.push([x, y])\r\n            }\r\n            if (triangleContains(width, parseInt(height / 2) - parseInt(startAreaHeight / 2), width - startAreaWidth, parseInt(height / 2), width, parseInt(height / 2) + parseInt(startAreaHeight / 2), x, y)) {\r\n                teamBTiles.push([x, y])\r\n            }\r\n        }\r\n    }\r\n    map = {\r\n        tiles: tiles, teamA: teamATiles, teamB: teamBTiles, allTiles: tiles\r\n    }\r\n    map.tiles = map.tiles.filter(f => !map.teamA.filter(a => a[0] === f[0] && a[1] === f[1]).length && !map.teamB.filter(b => f[0] === b[0] && f[1] === b[1]).length)\r\n    return map\r\n}\r\n\r\nexport { buildMap, drawMap, gridDimensions as gridSize, addUnit, setPlacingSprite, getUnits }","import { gridSize } from \"./map.js\"\r\nimport { buildSprite } from \"./sprites.js\"\r\nimport { getContext } from \"./images.js\"\r\n\r\nclass Actor {\r\n    constructor(params) {\r\n        this.team = params.team\r\n        this.name = params.name\r\n        this.character = params.character\r\n        this.sprite = buildSprite(params.spriteName, params.x ? params.x : 0, params.y ? params.y : 0, 'idle')\r\n    }\r\n\r\n    Position() {\r\n        return { x: this.sprite.x, y: this.sprite.y }\r\n    }\r\n\r\n    MapCoords() {\r\n        return { x: parseInt(this.sprite.x / gridSize().x), y: parseInt(this.sprite.y / gridSize().y) }\r\n    }\r\n\r\n    Draw(delta) {\r\n        this.sprite.draw(delta)\r\n    }\r\n}\r\n\r\nexport default Actor\r\n","import { getContext } from \"./images.js\"\r\nimport { drawMap, getUnits, setPlacingSprite } from \"./map.js\"\r\nimport { currentPhase, currentTeam } from \"./teams.js\"\r\nimport { pointer } from \"./main.js\"\r\n\r\nlet imu = null\r\n\r\nlet ctx = null\r\n\r\nlet tooltip = ''\r\n\r\nfunction drawFrame(delta) {\r\n    if (!ctx) {\r\n        ctx = getContext()\r\n    }\r\n    ctx.clearRect(0, 0, 320, 200)\r\n\r\n    drawMap(delta)\r\n\r\n    drawUI(delta)\r\n}\r\n\r\nfunction handleAction() {\r\n    if (currentPhase() === 'positioning') {\r\n        let units = getUnits(currentTeam().name)\r\n        console.log(currentTeam())\r\n        if (units.length > 0) {\r\n            setPlacingSprite(units[0].sprite)\r\n        }\r\n    }\r\n}\r\n\r\nfunction StartScene() {\r\n    handleAction()\r\n}\r\n\r\nfunction drawUI(delta) {\r\n    if (!imu) {\r\n        imu = new imui.ImUI(ctx.canvas)\r\n        imu.font = font\r\n\r\n        imu.onUpdate = (ui) => {\r\n            let phase = currentPhase().slice(0, 1).toUpperCase() + currentPhase().slice(1)\r\n            ui.Element({ id: 'lblPhase', text: `${phase}: ${currentTeam().name}`, rect: { x: 10, y: 3, w: 300, h: 9 }, color: '#f1f100ff', color: '#f1f100ff', bgcolor: '#000000cc'})\r\n\r\n            ui.Element({ id: 'lblTooltip', text: tooltip, rect: { x: 0, y: 0, w: 240, h: 10 }, color: '#f1f1f1ff', highlight: '#f1f1f1ff', bgcolor: '#cccccc00' })\r\n        }\r\n    }\r\n    imu.Draw()\r\n}\r\n\r\nexport { drawFrame, StartScene }","import maps from './keymapping.json'\r\n\r\nvar listening = false\r\n\r\nfunction handlerPressed (button) {\r\n  setState(button, true)\r\n}\r\n\r\nfunction handlerReleased (button) {\r\n  setState(button, false)\r\n  if (callbacks[button]) {\r\n    callbacks[button](button)\r\n  }\r\n}\r\n\r\nfunction GetInputKeys(inputType) {\r\n  inputType = inputType.toLowerCase()\r\n  return Object.keys(maps[inputType])\r\n}\r\n\r\nfunction GetInputValue(inputType, key) {\r\n  inputType = inputType.toLowerCase()\r\n  return maps[inputType][key]\r\n}\r\n\r\nvar inputState = {}\r\nvar callbacks = {}\r\n\r\nvar enabled = [ 'keyboard', 'gamepad' ]\r\n\r\nfunction setState(button, value) {\r\n  inputState[button] = value\r\n}\r\n\r\nfunction getState(button) {\r\n  if (!listening) {\r\n    return false\r\n  }\r\n  return inputState[button] ? inputState[button] : false\r\n}\r\n\r\nfunction listenerKeyDown(e) {\r\n  if (!listening) {\r\n    return\r\n  }\r\n  let inputs = Object.keys(maps.keyboard)\r\n  for (let i in inputs) {\r\n    if (e.key === maps.keyboard[inputs[i]]) {\r\n      handlerPressed(inputs[i])\r\n    }\r\n  }\r\n}\r\n\r\nfunction listenerKeyUp(e) {\r\n  if (!listening) {\r\n    return\r\n  }\r\n  let inputs = Object.keys(maps.keyboard)\r\n  for (let i in inputs) {\r\n    if (e.key === maps.keyboard[inputs[i]]) {\r\n      handlerReleased(inputs[i])\r\n    }\r\n  }\r\n}\r\n\r\nfunction init() {\r\n  inputState = {}\r\n  callbacks = {}\r\n  if (enabled.includes('keyboard')) {\r\n    window.removeEventListener('keydown', listenerKeyDown)\r\n    window.removeEventListener('keyup', listenerKeyUp)\r\n    window.addEventListener('keydown', listenerKeyDown)\r\n    window.addEventListener(\"keyup\", listenerKeyUp)\r\n  }\r\n  if (enabled.includes('gamepad')) {\r\n    gameControl.on('connect', function(gamepad) {\r\n      let inputs = Object.keys(maps.gamepad)\r\n      for (let i in inputs) {\r\n        gamepad.on(maps.gamepad[inputs[i]], () => {\r\n          \r\n        }).after(maps.gamepad[inputs[i]], () => {\r\n          handlerReleased(inputs[i])\r\n        })\r\n      }\r\n    })\r\n  }\r\n  listening = false\r\n}\r\n\r\ninit()\r\n\r\nvar input = {\r\n  listen: () => {\r\n    listening = true\r\n  },\r\n  unlisten: () => {\r\n    listening = false\r\n  },\r\n  released: (button, method) => {\r\n    callbacks[button] = method\r\n  }\r\n}\r\n\r\nexport default input\r\nexport { GetInputKeys, GetInputValue }","import { Pipeline } from './pipeline.js'\r\n\r\nimport characters from \"./characters.json\"\r\n\r\nclass Character {\r\n    constructor(name) {\r\n        // data property holds base class data from json\r\n        try {\r\n            this.data = characters.filter(f => f.name === name)[0]\r\n            this.data.maxHp = this.data.hp\r\n            this.name = this.data.name\r\n            this.equipment = []\r\n        } catch {\r\n            this.data = {}\r\n            console.error(`Could not locate template for ${name}.`)\r\n        }\r\n\r\n        // effectModifiers property holds active effect modifiers.\r\n        this.effectModifiers = {}\r\n\r\n        // Active effect modifiers, evaluated each phase and removed when\r\n        // expired.\r\n        this.effects = []\r\n    }\r\n\r\n    /**\r\n     * Iterate over the effects currently active on this character and\r\n     * do housekeeping (decrement ttl, removing ttl = 0, etc.)\r\n     */\r\n    UpdateEffects() {\r\n        for (let e in this.effects) {\r\n            let effect = this.effects[e]\r\n            if (effect.ttl) {\r\n                effect.ttl--\r\n            }\r\n            if (effect.ttl <= 0) {\r\n                this.RemoveEffectModifier(effect)\r\n            }\r\n        }\r\n        this.effects = this.effects.filter(f => f.ttl > 0)\r\n    }\r\n\r\n    AddEffect(effect) {\r\n        if (effect.ttl) {\r\n            this.effects.push(effect)\r\n        }\r\n        if (effect.attribute !== undefined) {\r\n            this.AddEffectModifier(effect.attribute, effect.amount)\r\n        }\r\n    }\r\n    RemoveEffectModifier(effect) {\r\n        if (effect.attribute !== undefined) {\r\n            this.AddEffect(effect.attribute, effect.amount * -1)\r\n        }\r\n    }\r\n\r\n    AddEffectModifier(attribute, amount) {\r\n        if (this.effectModifiers[attribute] === undefined) {\r\n            this.effectModifiers[attribute] = 0\r\n        }\r\n        this.effectModifiers[attribute] += amount\r\n    }\r\n\r\n    EffectModifier(attribute) {\r\n        if (this.effectModifiers[attribute] !== undefined) {\r\n            return this.effectModifiers[attribute]\r\n        }\r\n        return 0\r\n    }\r\n\r\n    Name() {\r\n        return this.data.name\r\n    }\r\n\r\n    Cost() {\r\n        return this.data.Cost + this.EffectModifier('cost')\r\n    }\r\n\r\n    EquipmentAndAbilities(eqab) {\r\n        if (eqab !== undefined) {\r\n            this.data.equipAbilities = eqab\r\n        }\r\n        return this.data.equipAbilities + this.EffectModifier('equipAbilities')\r\n    }\r\n\r\n    GunnerySkill() {\r\n        return this.data.gunnerySkill + this.EffectModifier('gunnerySkill')\r\n    }\r\n\r\n    MeleeSkill() {\r\n        return this.data.meleeSkill + this.EffectModifier('meleeSkill')\r\n    }\r\n\r\n    Speed() {\r\n        return this.data.speed + this.EffectModifier('speed')\r\n    }\r\n\r\n    Hp() {\r\n        return this.data.hp + this.EffectModifier('hp')\r\n    }\r\n\r\n    MaxHp() {\r\n        return this.data.maxHp + this.EffectModifier('maxHp')\r\n    }\r\n}\r\n\r\n export { Character }","import input, { GetInputKeys, GetInputValue } from './input.js'\r\nimport { getContext, drawImage, getImage } from \"./images.js\"\r\nimport { Start, pointer } from './main.js'\r\nimport { Character } from './character.js'\r\nimport { buildSprite } from './sprites.js'\r\n\r\nimport menus from './menus.json'\r\nimport equipment from './equipment.json'\r\nimport { buildMap } from './map.js'\r\nimport { addTeam } from './teams.js'\r\n\r\nlet imu = null\r\n\r\nlet ctx = null\r\n\r\nvar stars = 16\r\n\r\nvar squad = []\r\n\r\nvar background = buildSprite('background', 0, 0, 'idle')\r\n\r\nvar menu = null\r\nvar menuItems = []\r\nvar menuItem = {}\r\nvar currentMenuId = 'Main'\r\nvar currentMenuItem = 'Start'\r\nvar currentMenuColumn = 0\r\n\r\nvar currentCharacterEquip = null\r\n\r\nvar menuMethods = {\r\n    callback_OnRenderStars: (text, replacements) => {\r\n        return [stars.toString()]\r\n    },\r\n    callback_OnRenderHireSquad: (text, replacements) => {\r\n        return [squad.length]\r\n    },\r\n\r\n    callback_OnRenderCharacter: (text, replacements) => {\r\n        let name = text.split(' ')[0].replace('>', '')\r\n        return [(squad.filter(f => f.name === name).length)]\r\n    },\r\n\r\n    callback_HireCharacter: (text) => {\r\n        let name = text.split(' ')[0].replace('>', '')\r\n        let char = new Character(name)\r\n        if (stars - char.Cost() >= 0) {\r\n            squad.push(char)\r\n            stars -= char.Cost()\r\n        }\r\n    },\r\n\r\n    callback_StartGame: () => {\r\n        buildMap()\r\n        Start(squad)\r\n    },\r\n\r\n    callback_SelectCharacterEquip: (text) => {\r\n        currentCharacterEquip = text\r\n    },\r\n\r\n    callback_SetupEquipment: (text) => {\r\n        ChangeMenu('SetupEquipment')\r\n        let menu = menus.filter(f => f.id === 'SetupEquipment')[0]\r\n        let nextIndex = menu.Options.findIndex(f => f.text === 'Next')\r\n        menu.Options = [\r\n            ...squad.map((m, i) => {\r\n            return {\r\n                text: `${i + 1}. ${m.name}`,\r\n                onSelect: 'callback_SelectCharacterEquip',\r\n                width: 160,\r\n                column: 0\r\n            }}),\r\n            menu.Options[nextIndex]\r\n        ]\r\n    }\r\n}\r\n\r\nlet menuDx = 0\r\nlet menuDy = 0\r\n\r\nfunction Action(actionId) {\r\n    if (actionId.includes('callback_')) {\r\n        return menuMethods[actionId] ? menuMethods[actionId] : () => {}\r\n    } else if (actionId.includes('menu_')) {\r\n        let action = actionId.split('_')\r\n        ChangeMenu(action[1])\r\n    }\r\n    return () => {}\r\n}\r\n\r\nfunction ChangeMenu(id) {\r\n    input.unlisten()\r\n    currentMenuColumn = 0\r\n    currentMenuId = id\r\n    let menuItems = GetMenuItems(id)\r\n    input.listen()\r\n    menuItem = menuItems.filter(f => f.text === currentMenuItem)[0]\r\n}\r\n\r\nfunction GetMenuItems(menuId) {\r\n    let menu = GetMenu(menuId)\r\n    let items = menu.Options.filter(f => f.onSelect && (f.column === undefined || f.column === currentMenuColumn))\r\n    if (items.length > 0 && currentMenuItem === '') {\r\n        currentMenuItem = items[0].text\r\n    }\r\n    return items\r\n}\r\n\r\nfunction GetMenu(id) {\r\n    try {\r\n        return menus.filter(f => f.id === id)[0]\r\n    } catch { return null }\r\n}\r\n\r\nfunction StartMenu(id) {\r\n    input.listen()\r\n\r\n    input.released('moveDown', () => {\r\n        menu = GetMenu(currentMenuId)\r\n        menuItems = GetMenuItems(currentMenuId) //menu.Options.filter(f => f.onSelect)\r\n        menuItem = menuItems.filter(f => f.text === currentMenuItem)[0]\r\n        let index = menuItems.findIndex(f => f.text === currentMenuItem)\r\n        index++\r\n        if (index >= menuItems.length) {\r\n            index = 0\r\n        }\r\n        currentMenuItem = menuItems[index].text\r\n    })\r\n    input.released('moveUp', () => {\r\n        menu = GetMenu(currentMenuId)\r\n        menuItems = GetMenuItems(currentMenuId)//menu.Options.filter(f => f.onSelect)\r\n        menuItem = menuItems.filter(f => f.text === currentMenuItem)[0]\r\n        let index = menuItems.findIndex(f => f.text === currentMenuItem)\r\n        index--\r\n        if (index < 0) {\r\n            index = menuItems.length - 1\r\n        }\r\n        currentMenuItem = menuItems[index].text\r\n    })\r\n    input.released('attack', () => {\r\n        menu = GetMenu(currentMenuId)\r\n        menuItems = GetMenuItems(currentMenuId) //menu.Options.filter(f => f.onSelect)\r\n        try {\r\n            menuItem = menuItems.filter(f => f.text === currentMenuItem)[0]    \r\n            if (menuItem.onSelect) {\r\n                Action(menuItem.onSelect)(menuItem.text)\r\n            }\r\n        } catch {}\r\n    })\r\n}\r\n\r\nfunction drawFrame(delta) {\r\n    if (!ctx) {\r\n        ctx = getContext()\r\n    }\r\n    background.draw(0, 0)\r\n    background.update(delta)\r\n    drawUI(delta)\r\n}\r\n\r\nfunction OnRender(text, onRender) {\r\n    let arr = text.split(/{[0-9]}/)\r\n    let replacements = []\r\n    for (let r in arr) {\r\n        replacements.push(`{${r}}`)\r\n    }\r\n    let values = Action(onRender)(text, arr)\r\n    for (let v in values) {\r\n        text = text.replace(replacements[v], values[v])\r\n    }\r\n    return text\r\n}\r\n\r\nfunction drawUI(delta) {\r\n    if (!imu) {\r\n        imu = new imui.ImUI(ctx.canvas)\r\n        imu.font = font\r\n        \r\n        imu.onUpdate = (ui) => {\r\n            //ui.Element({ id: 'imgGamename', type: 'Image', x: 10, y: 10, image: getImage('title') })\r\n            let menu = GetMenu(currentMenuId)\r\n            let menuItems = menu.Options.sort((a, b) => b.column !== undefined ? b.column : 0 - a.column !== undefined ? a.column : 0)\r\n            //imu.RemoveElements()\r\n            let dy = menuDy + 30\r\n            for (let i in menuItems) {\r\n                let item = menuItems[i].text\r\n                let menuItem = menuItems[i]\r\n                let colr = item === currentMenuItem ? menu.Style.SelectColor : menuItem.onSelect ? menu.Style.SelectableColor : menu.Style.Color\r\n                let txt = `${currentMenuItem === item ? '>' : ' '}${item}${currentMenuItem === item ? '<' : ' ' }`\r\n                if (txt.includes('{') && txt.includes('}') && menuItem.onRender) {\r\n                    txt = OnRender(txt, menuItem.onRender)\r\n                }\r\n                let el = ui.Element({ id: 'lblMenu' + currentMenuId + item + i, text: txt, rect: { x: menuDx, y: dy, w: 64, h: 8 }, color: colr, highlight: colr, bgcolor: '#cccccc00' })\r\n\r\n                if (el.Hover()) {\r\n                    if (menuItem.onSelect) {\r\n                        currentMenuItem = item\r\n                    }\r\n                }\r\n                if (el.Clicked()) {\r\n                    if (menuItem.onSelect) {\r\n                        currentMenuItem = txt\r\n                        Action(menuItem.onSelect)(menuItem.text)\r\n                    }\r\n                }\r\n                dy += 12\r\n            }\r\n            if (currentMenuId === 'SetupEquipment') {\r\n                let elEquip = ui.Element({ id: 'lblEquipMenu', text: 'Squad Equipment', rect: { x: menuDx, y: menuDy + 15, w: 128, h: 8 }, color: menu.Style.Color, highlight: menu.Style.Color, bgcolor: '#cccccc00' })\r\n            }\r\n            if (currentCharacterEquip && currentMenuId === 'SetupEquipment') {\r\n                let tooltip = ''\r\n                dy = menuDy + 42\r\n                let colDx = 80\r\n                let charName = currentCharacterEquip.split('.')[1].trim()\r\n                let charIndex = parseInt(currentCharacterEquip.split('.')) - 1\r\n                let eqabPoints = squad[charIndex].EquipmentAndAbilities()\r\n                let elSelEquip = ui.Element({ id: 'lblSelEquip', text: `${charName}: Equip & Ability Points: ${eqabPoints}`, rect: { x: colDx, y: menuDy + 30, w: 128, h: 8 }, color: menu.Style.Color, highlight: menu.Style.Color, bgcolor: '#cccccc00' })\r\n                let equiplist = equipment.filter(f => f.characters.includes(charName))\r\n                for (let e in equiplist) {\r\n                    let equip = equiplist[e]\r\n                    let equipped = squad[charIndex].equipment.filter(f => equip.name === f.name)\r\n                    let colr = menu.Style.SelectableColor\r\n                    if (equipped.length > 0) {\r\n                        colr = menu.Style.Disabled\r\n                    }\r\n\r\n                    let el = ui.Element({ id: 'lblEquip' + currentMenuId + equip.name + e, text: equip.name, rect: { x: colDx, y: dy, w: 128, h: 8 }, color: colr, highlight: colr, bgcolor: '#cccccc00' })\r\n                    \r\n                    if (el.Hover()) {\r\n                        let attr = [`Attacks: ${equip.attacks}`, `Damage: ${equip.damage}`, `Range: ${equip.range}`, `Cost: ${equip.cost}`]\r\n                        if (equip.reload) {\r\n                            attr.push('Requires Reload')\r\n                        }\r\n                        tooltip = attr.join('\\n')\r\n                    }\r\n                    if (el.Clicked()) {\r\n                        if (equipped.length > 0) {\r\n                            squad[charIndex].equipment = squad[charIndex].equipment.filter(f => f.name !== equip.name)\r\n                            squad[charIndex].EquipmentAndAbilities(eqabPoints + equip.cost)\r\n                        } else {\r\n                            if (eqabPoints - equip.cost >= 0) {\r\n                                squad[charIndex].equipment.push(equip)\r\n                                squad[charIndex].EquipmentAndAbilities(eqabPoints - equip.cost)\r\n                            }\r\n                        }\r\n                    }\r\n                        \r\n                    dy += 12\r\n                    if (dy > 180) {\r\n                        dy = menuDy + 42\r\n                        colDx += 90\r\n                    }\r\n                }\r\n\r\n                if (tooltip) {\r\n                    ui.RemoveElement('lblTooltip')\r\n                    let tip = ui.Element({ id: 'lblTooltip', text: tooltip, x: pointer.x, y: pointer.y + 8, autosize: true, color: menu.Style.SelectableColor, highlight: menu.Style.SelectColor, bgcolor: '#000000dd' })\r\n                }\r\n            }\r\n        }\r\n    }\r\n    imu.Draw()\r\n}\r\n\r\nexport { drawFrame, StartMenu }","import images from './images.js'\r\nimport sfx from './sfx.js'\r\nimport music from './music.js'\r\nimport sprites from './sprites.js'\r\nimport Actor from './actor.js'\r\nimport { setContext, loadAllImages } from './images.js'\r\nimport { drawFrame as drawMain, StartScene } from './mainScene.js'\r\nimport { drawFrame as drawMainMenu, StartMenu } from './menuScene.js'\r\nimport { set, setDictionary } from './grammar.js'\r\nimport input from './input.js'\r\nimport { addTeam, currentTeam } from './teams.js'\r\nimport { addUnit } from './map.js'\r\n\r\nvar dateNow = Date.now()\r\nvar dateThen = Date.now()\r\n\r\nvar targetDelta = 16 // Roughly 60fps by default\r\n\r\nvar currentScene = 'mainMenu'\r\n\r\nvar pointer = { x: 0, y: 0 }\r\n\r\nfunction setTargetFrameRate(target) {\r\n    targetDelta = parseInt(1000 / target) // Number of ms divided by target fps\r\n}\r\n\r\nfunction requestAnimationFrame() {\r\n    dateNow = Date.now()\r\n    let delta = dateNow - dateThen\r\n    if (delta >= targetDelta) {\r\n        drawFrame(delta)\r\n        dateThen = dateNow\r\n    }\r\n    window.requestAnimationFrame(requestAnimationFrame)\r\n}\r\n\r\n/**\r\n * Draws the animation frame.\r\n * @param {number} delta Number of ms since last frame.\r\n */\r\nfunction drawFrame(delta) {\r\n    if (currentScene === 'mainMenu') {\r\n        drawMainMenu(delta)\r\n    } else if (currentScene === 'main') {\r\n        drawMain(delta)\r\n    }\r\n}\r\n\r\nasync function StartMainMenu() {\r\n    await loadAllImages()\r\n\r\n    let canvas = document.getElementById('maincanvas')\r\n    let ratio = canvas.width / canvas.height\r\n    canvas.style.height = window.innerHeight + 'px'\r\n    canvas.style.width = window.innerHeight * ratio + 'px'\r\n    window.addEventListener('resize', () => {\r\n        canvas.style.height = window.innerHeight + 'px'\r\n        canvas.style.width = window.innerHeight * ratio + 'px'\r\n      })\r\n        \r\n    canvas.addEventListener('mousemove', (e) => {\r\n        pointer.x = parseInt((e.clientX - canvas.offsetLeft) * (canvas.width / parseInt(canvas.style.width))) - 2\r\n        pointer.y = parseInt((e.clientY - canvas.offsetTop) * (canvas.height / parseInt(canvas.style.height)))\r\n    })\r\n\r\n    canvas.addEventListener('contextmenu', (e) => {\r\n        e.preventDefault()\r\n        return false\r\n    })     \r\n\r\n    setTargetFrameRate(60)\r\n    setContext(canvas.getContext('2d'))\r\n\r\n    StartMenu()\r\n\r\n    window.requestAnimationFrame(requestAnimationFrame)\r\n}\r\n\r\nasync function Start(squad) {\r\n\r\n    input.unlisten()\r\n    let canvas = document.getElementById('maincanvas')\r\n    currentScene = 'main'\r\n\r\n    addTeam('Team Alpha', '2d10')\r\n    addTeam('Team Bravo', '1d1')\r\n    \r\n    for (let s in squad) {\r\n        addUnit('Team Alpha', squad[s])\r\n    }\r\n\r\n    setTargetFrameRate(60)\r\n    setContext(canvas.getContext('2d'))\r\n\r\n    StartScene()\r\n\r\n    window.requestAnimationFrame(requestAnimationFrame)\r\n}\r\n\r\nexport { Start, StartMainMenu, pointer }"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","ctx","setContext","context","getContext","drawImage","name","x","y","srcRect","img","f","length","image","w","h","getMsSinceMidnight","d","Date","setHours","buildSprite","pose","onComplete","Error","sprite","frames","framesImage","currentFrame","updateDelta","play","animation","animStartTime","anim","sprPose","default","filter","imageName","sfx","getSfx","offsetx","offsety","async","speed","Promise","resolve","reject","spr","ox","oy","spd","t","mx","my","handler","p","amt","start","end","setTimeout","update","delta","frameDelay","repeat","animDuration","SetAnimation","roll","dice","toLowerCase","includes","dieterm","split","times","min","max","Math","floor","random","teams","teamIndex","phases","phase","addTeam","turnOrderRollDice","team","color","order","push","sort","a","b","getTeam","currentTeam","currentPhase","map","height","gridOpacity","placingSprite","units","camera","gridDimensions","targetX","targetY","triangleContains","ax","ay","bx","by","cx","cy","det","addUnit","teamName","unit","actor","character","spriteName","getUnits","console","log","constructor","params","this","Position","MapCoords","parseInt","Draw","draw","imu","tooltip","handleAction","listening","handlerReleased","button","setState","callbacks","inputState","enabled","listenerKeyDown","e","inputs","keys","i","listenerKeyUp","window","removeEventListener","addEventListener","gameControl","on","gamepad","after","listen","unlisten","released","method","Character","data","maxHp","hp","equipment","error","effectModifiers","effects","UpdateEffects","effect","ttl","RemoveEffectModifier","AddEffect","undefined","attribute","AddEffectModifier","amount","EffectModifier","Name","Cost","EquipmentAndAbilities","eqab","equipAbilities","GunnerySkill","gunnerySkill","MeleeSkill","meleeSkill","Speed","Hp","MaxHp","stars","squad","background","menuItems","menuItem","currentMenuId","currentMenuItem","currentMenuColumn","currentCharacterEquip","menuMethods","callback_OnRenderStars","text","replacements","toString","callback_OnRenderHireSquad","callback_OnRenderCharacter","replace","callback_HireCharacter","char","callback_StartGame","tiles","teamATiles","teamBTiles","startAreaHeight","width","teamA","teamB","allTiles","buildMap","Start","callback_SelectCharacterEquip","callback_SetupEquipment","ChangeMenu","menu","id","nextIndex","Options","findIndex","m","onSelect","column","menuDx","menuDy","Action","actionId","GetMenuItems","menuId","items","GetMenu","OnRender","onRender","arr","r","values","v","dateNow","now","dateThen","targetDelta","currentScene","pointer","setTargetFrameRate","target","requestAnimationFrame","imui","ImUI","canvas","font","onUpdate","ui","dy","item","colr","Style","SelectColor","SelectableColor","Color","txt","el","Element","rect","highlight","bgcolor","Hover","Clicked","colDx","charName","trim","charIndex","eqabPoints","equiplist","characters","equip","equipped","Disabled","attr","attacks","damage","range","cost","reload","join","RemoveElement","autosize","clearRect","save","translate","ga","globalAlpha","restore","drawMap","slice","toUpperCase","StartMainMenu","promises","loadImage","filename","Image","onload","onerror","src","then","catch","allSettled","loadAllImages","document","getElementById","ratio","style","innerHeight","clientX","offsetLeft","clientY","offsetTop","preventDefault","index","s"],"sourceRoot":""}